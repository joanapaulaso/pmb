Installation
Quill comes ready to use in several convenient forms.

CDN
A globally distributed and available CDN is provided, backed by jsDelivr. This is the most convenient way to get started with Quill, and requires no build steps or package managers.

Full Build
For most users, the full build is the easiest way to get started with Quill. It include the core Quill library, as well as common themes, formats, and modules.

To import the full build, you will need to include the "quill.js" script and the stylesheet for the theme you wish to use.

<script src="https://cdn.jsdelivr.net/npm/quill@2.0.3/dist/quill.js"></script>
<link href="https://cdn.jsdelivr.net/npm/quill@2.0.3/dist/quill.snow.css" rel="stylesheet">

<div id="editor">
  <h2>Demo Content</h2>
  <p>Preset build with <code>snow</code> theme, and some common formats.</p>
</div>

<script>
  const quill = new Quill('#editor', {
    theme: 'snow'
  });
</script>
Note
Learn more about how to customize the toolbar.

Core Build
To fully customize your Quill build, you can import the core library and add only the formats and modules you need.

<link href="https://cdn.jsdelivr.net/npm/quill@2.0.3/dist/quill.core.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/quill@2.0.3/dist/quill.core.js"></script>

<div id="editor">
  <p>Core build with no theme, formatting, non-essential modules</p>
</div>

<script>
  const quill = new Quill('#editor');
</script>
Note
Learn more about how to make your own formats.

CDN builds expose Quill to the global window object. Quill provides an import() method for accessing components of the Quill library, including its formats, modules, or themes.

npm
If your project uses bundlers such as Webpack or Vite, it's recommended to install Quill via npm.

npm install quill@2.0.3
Similar to the CDN approach, you can import the full build from "quill" or the core build from "quill/core".

import Quill from 'quill';
// Or if you only need the core build
// import Quill from 'quill/core';

const quill = new Quill('#editor');
Note
If you want to use the core build, avoid importing "quill" directly throughout your project. Doing so results in a full build, as "quill" registers the full build's formats and modules upon import.

Quill.import() is also available for the npm build to access Quill's library. However, a more natural approach in npm enviroment is to import the formats and modules directly.

import Quill from 'quill';
// Or if you only need the core build
// import Quill from 'quill/core';

import { Delta } from 'quill';
// Or if you only need the core build
// import { Delta } from 'quill/core';
// Or const Delta = Quill.import('delta');

import Link from 'quill/formats/link';
// Or const Link = Quill.import('formats/link');
Styles
Quill's npm package also comes with the stylesheets for the core and themes, just like the CDN build. Those stylesheets live in the dist directory.

You can import them in your JavaScript files if you have a proper bundler setup.

import "quill/dist/quill.core.css";
Refer to webpack-example for a sample project that uses Quill in a webpack project.


Documentation
Configuration
Edit page on GitHub ↗
Configuration
Quill allows several ways to customize it to suit your needs. This section is dedicated to tweaking existing functionality. See the Modules section for adding new functionality and the Themes section for styling.

Container
Quill requires a container where the editor will be appended. You can pass in either a CSS selector or a DOM object.

const quill = new Quill('#editor');  // First matching element will be used
const container = document.getElementById('editor');
const quill = new Quill(container);
If the container is not empty, Quill will initialize with the existing contents.

Options
To configure Quill, pass in an options object:

const options = {
  debug: 'info',
  modules: {
    toolbar: true,
  },
  placeholder: 'Compose an epic...',
  theme: 'snow'
};
const quill = new Quill('#editor', options);
The following keys are recognized:

bounds
Default: document.body

DOM Element or a CSS selector for a DOM Element, within which the editor's ui elements (i.e. tooltips, etc.) should be confined. Currently, it only considers left and right boundaries.

debug
Default: warn

Shortcut for debug. Note debug is a static method and will affect other instances of Quill editors on the page. Only warning and error messages are enabled by default.

formats
Default: null

A list of formats that are recognized and can exist within the editor contents.

By default, all formats that are defined in the Quill library are allowed. To restrict formatting to a smaller list, pass in an array of the format names to support.

You can create brand new formats or more fully customize the content using Registries. Specifying a registry option will ignore this formats option.

index.html
index.js
const Parchment = Quill.import('parchment');

const quill = new Quill('#editor', {
  formats: ['italic'],
});

const Delta = Quill.import('delta');
quill.setContents(
  new Delta()
    .insert('Only ')
    .insert('italic', { italic: true })
    .insert(' is allowed. ')
    .insert('Bold', { bold: true })
    .insert(' is not.')
);

placeholder
Default: None

Placeholder text to show when editor is empty.

const options = {
  placeholder: 'Hello, World!',
  theme: 'snow'
};
const quill = new Quill('#editor', options);
readOnly
Default: false

Whether to instantiate the editor to read-only mode.

const options = {
  readOnly: true,
  modules: {
    toolbar: null
  },
  theme: 'snow'
};
const quill = new Quill('#editor', options);
const Delta = Quill.import('delta');
quill.setContents(
  new Delta()
    .insert('Hello, ')
    .insert('World', { bold: true })
    .insert('\n')
);
registry
Default: null

By default all formats defined by Quill are supported in the editor contents through a shared registry between editor instances. Use formats to restrict formatting for simple use cases and registry for greater customization. Specifying this registry option will ignore the formatting option. Learn more about Registries.

theme
Name of theme to use. The builtin options are "bubble" or "snow". An invalid or falsy value will load a default minimal theme. Note the theme's specific stylesheet still needs to be included manually. See Themes for more information.



Documentation
Formats
Edit page on GitHub ↗
Formats
Quill supports a number of formats, both in UI controls and API calls.

By default, all formats are enabled and allowed in a Quill editor. They can be configured with the formats option. This is separate from adding a control in the Toolbar. For example, you can configure Quill to allow bolded content to be pasted into an editor that has no bold button in the toolbar.


Standalone

Inline
Background Color - background
Bold - bold
Color - color
Font - font
Inline Code - code
Italic - italic
Link - link
Size - size
Strikethrough - strike
Superscript/Subscript - script
Underline - underline
Block
Blockquote - blockquote
Header - header
Indent - indent
List - list
Text Alignment - align
Text Direction - direction
Code Block - code-block
Embeds
Formula - formula (requires KaTeX)
Image - image
Video - video


Documentation
API
Edit page on GitHub ↗
API
Content
deleteText
getContents
getLength
getText
getSemanticHTML
insertEmbed
insertText
setContents
setText
updateContents
Formatting
format
formatLine
formatText
getFormat
removeFormat
Selection
getBounds
getSelection
setSelection
scrollSelectionIntoView
Editor
blur
focus
disable
enable
hasFocus
update
scrollRectIntoView
Events
text-change
selection-change
editor-change
off
on
once
Model
find
getIndex
getLeaf
getLine
getLines
Extension
debug
import
register
addContainer
getModule
Content
deleteText
Deletes text from the editor, returning a Delta representing the change. Source may be "user", "api", or "silent". Calls where the source is "user" when the editor is disabled are ignored.

Methods

deleteText(index: number, length: number, source: string = 'api'): Delta
Example 1

quill.deleteText(6, 4);
Example 2

const quill = new Quill('#editor', { theme: 'snow' });

document.querySelector('#deleteButton').addEventListener('click', () => {
  quill.deleteText(5, 7);
});
getContents
Retrieves contents of the editor, with formatting data, represented by a Delta object.

Methods

getContents(index: number = 0, length: number = remaining): Delta
Examples

const delta = quill.getContents();
getLength
Retrieves the length of the editor contents. Note even when Quill is empty, there is still a blank line represented by '\n', so getLength will return 1.

Methods

getLength(): number
Examples

const length = quill.getLength();
getText
Retrieves the string contents of the editor. Non-string content are omitted, so the returned string's length may be shorter than the editor's as returned by getLength. Note even when Quill is empty, there is still a blank line in the editor, so in these cases getText will return '\n'.

The length parameter defaults to the length of the remaining document.

Methods

getText(index: number = 0, length: number = remaining): string
Examples

const text = quill.getText(0, 10);
getSemanticHTML
Get the HTML representation of the editor contents. This method is useful for exporting the contents of the editor in a format that can be used in other applications.

The length parameter defaults to the length of the remaining document.

Methods

getSemanticHTML(index: number = 0, length: number = remaining): string
Examples

const html = quill.getSemanticHTML(0, 10);
insertEmbed
Insert embedded content into the editor, returning a Delta representing the change. Source may be "user", "api", or "silent". Calls where the source is "user" when the editor is disabled are ignored.

Methods

insertEmbed(index: number, type: string, value: any, source: string = 'api'): Delta
Examples

quill.insertEmbed(10, 'image', 'https://quilljs.com/images/cloud.png');
insertText
Inserts text into the editor, optionally with a specified format or multiple formats. Returns a Delta representing the change. Source may be "user", "api", or "silent". Calls where the source is "user" when the editor is disabled are ignored.

Methods

insertText(index: number, text: string, source: string = 'api'): Delta
insertText(index: number, text: string, format: string, value: any,
           source: string = 'api'): Delta
insertText(index: number, text: string, formats: { [name: string]: any },
           source: string = 'api'): Delta
Examples

quill.insertText(0, 'Hello', 'bold', true);

quill.insertText(5, 'Quill', {
  color: '#ffff00',
  italic: true,
});
setContents
Overwrites editor with given contents. Contents should end with a newline. Returns a Delta representing the change. This will be the same as the Delta passed in, if given Delta had no invalid operations. Source may be "user", "api", or "silent". Calls where the source is "user" when the editor is disabled are ignored.

Methods

setContents(delta: Delta, source: string = 'api'): Delta
Examples

quill.setContents([
  { insert: 'Hello ' },
  { insert: 'World!', attributes: { bold: true } },
  { insert: '\n' },
]);
setText
Sets contents of editor with given text, returning a Delta representing the change. Note Quill documents must end with a newline so one will be added for you if omitted. Source may be "user", "api", or "silent". Calls where the source is "user" when the editor is disabled are ignored.

Methods

setText(text: string, source: string = 'api'): Delta
Examples

quill.setText('Hello\n');
updateContents
Applies Delta to editor contents, returning a Delta representing the change. These Deltas will be the same if the Delta passed in had no invalid operations. Source may be "user", "api", or "silent". Calls where the source is "user" when the editor is disabled are ignored.

Methods

updateContents(delta: Delta, source: string = 'api'): Delta
Examples

// Assuming editor currently contains [{ insert: 'Hello World!' }]
quill.updateContents(new Delta()
  .retain(6)                  // Keep 'Hello '
  .delete(5)                  // 'World' is deleted
  .insert('Quill')
  .retain(1, { bold: true })  // Apply bold to exclamation mark
);
// Editor should now be [
//  { insert: 'Hello Quill' },
//  { insert: '!', attributes: { bold: true} }
// ]
Note
This method updates the contents from the beginning, not from the current selection. Use Delta#retain(length: number) to skip the contents you wish to leave unchanged.

Formatting
format
Format text at user's current selection, returning a Delta representing the change. If the user's selection length is 0, i.e. it is a cursor, the format will be set active, so the next character the user types will have that formatting. Source may be "user", "api", or "silent". Calls where the source is "user" when the editor is disabled are ignored.

Methods

format(name: string, value: any, source: string = 'api'): Delta
Examples

quill.format('color', 'red');
quill.format('align', 'right');
formatLine
Formats all lines in given range, returning a Delta representing the change. See formats for a list of available formats. Has no effect when called with inline formats. To remove formatting, pass false for the value argument. The user's selection may not be preserved. Source may be "user", "api", or "silent". Calls where the source is "user" when the editor is disabled are ignored.

Methods

formatLine(index: number, length: number, source: string = 'api'): Delta
formatLine(index: number, length: number, format: string, value: any,
           source: string = 'api'): Delta
formatLine(index: number, length: number, formats: { [name: string]: any },
           source: string = 'api'): Delta
Examples

quill.setText('Hello\nWorld!\n');

quill.formatLine(1, 2, 'align', 'right');   // right aligns the first line
quill.formatLine(4, 4, 'align', 'center');  // center aligns both lines
formatText
Formats text in the editor, returning a Delta representing the change. For line level formats, such as text alignment, target the newline character or use the formatLine helper. See formats for a list of available formats. To remove formatting, pass false for the value argument. The user's selection may not be preserved. Source may be "user", "api", or "silent". Calls where the source is "user" when the editor is disabled are ignored.

Methods

formatText(index: number, length: number, source: string = 'api'): Delta
formatText(index: number, length: number, format: string, value: any,
           source: string = 'api'): Delta
formatText(index: number, length: number, formats: { [name: string]: any },
           source: string = 'api'): Delta
Examples

quill.setText('Hello\nWorld!\n');

quill.formatText(0, 5, 'bold', true);      // bolds 'hello'

quill.formatText(0, 5, {                   // unbolds 'hello' and set its color to blue
  'bold': false,
  'color': 'rgb(0, 0, 255)'
});

quill.formatText(5, 1, 'align', 'right');  // right aligns the 'hello' line
getFormat
Retrieves common formatting of the text in the given range. For a format to be reported, all text within the range must have a truthy value. If there are different truthy values, an array with all truthy values will be reported. If no range is supplied, the user's current selection range is used. May be used to show which formats have been set on the cursor. If called with no arguments, the user's current selection range will be used.

Methods

getFormat(range: Range = current): Record<string, unknown>
getFormat(index: number, length: number = 0): Record<string, unknown>
Examples

quill.setText('Hello World!');
quill.formatText(0, 2, 'bold', true);
quill.formatText(1, 2, 'italic', true);
quill.getFormat(0, 2);   // { bold: true }
quill.getFormat(1, 1);   // { bold: true, italic: true }

quill.formatText(0, 2, 'color', 'red');
quill.formatText(2, 1, 'color', 'blue');
quill.getFormat(0, 3);   // { color: ['red', 'blue'] }

quill.setSelection(3);
quill.getFormat();       // { italic: true, color: 'blue' }

quill.format('strike', true);
quill.getFormat();       // { italic: true, color: 'blue', strike: true }

quill.formatLine(0, 1, 'align', 'right');
quill.getFormat();       // { italic: true, color: 'blue', strike: true,
                         //   align: 'right' }
removeFormat
Removes all formatting and embeds within given range, returning a Delta representing the change. Line formatting will be removed if any part of the line is included in the range. The user's selection may not be preserved. Source may be "user", "api", or "silent". Calls where the source is "user" when the editor is disabled are ignored.

Methods

removeFormat(index: number, length: number, source: string = 'api'): Delta
Examples

quill.setContents([
  { insert: 'Hello', { bold: true } },
  { insert: '\n', { align: 'center' } },
  { insert: { formula: 'x^2' } },
  { insert: '\n', { align: 'center' } },
  { insert: 'World', { italic: true }},
  { insert: '\n', { align: 'center' } }
]);

quill.removeFormat(3, 7);
// Editor contents are now
// [
//   { insert: 'Hel', { bold: true } },
//   { insert: 'lo\n\nWo' },
//   { insert: 'rld', { italic: true }},
//   { insert: '\n', { align: 'center' } }
// ]

Selection
getBounds
Retrieves the pixel position (relative to the editor container) and dimensions of a selection at a given location. The user's current selection need not be at that index. Useful for calculating where to place tooltips.

Methods

getBounds(index: number, length: number = 0):
  { left: number, top: number, height: number, width: number }
Examples

quill.setText('Hello\nWorld\n');
quill.getBounds(7); // Returns { height: 15, width: 0, left: 27, top: 31 }
getSelection
Retrieves the user's selection range, optionally to focus the editor first. Otherwise null may be returned if editor does not have focus.

Methods

getSelection(focus = false): { index: number, length: number }
Examples

const range = quill.getSelection();
if (range) {
  if (range.length == 0) {
    console.log('User cursor is at index', range.index);
  } else {
    const text = quill.getText(range.index, range.length);
    console.log('User has highlighted: ', text);
  }
} else {
  console.log('User cursor is not in editor');
}
setSelection
Sets user selection to given range, which will also focus the editor. Providing null as the selection range will blur the editor. Source may be "user", "api", or "silent".

Methods

setSelection(index: number, length: number = 0, source: string = 'api')
setSelection(range: { index: number, length: number },
             source: string = 'api')
Examples

quill.setSelection(0, 5);
scrollSelectionIntoView
Scroll the current selection into the visible area. If the selection is already visible, no scrolling will occur.

Note
Quill calls this method automatically when setSelection is called, unless the source is "silent".

Methods

scrollSelectionIntoView();
Examples

quill.scrollSelectionIntoView();
Editor
blur
Removes focus from the editor.

Methods

blur();
Examples

quill.blur();
disable
Shorthand for enable(false).

enable
Set ability for user to edit, via input devices like the mouse or keyboard. Does not affect capabilities of API calls, when the source is "api" or "silent".

Methods

enable(enabled: boolean = true);
Examples

quill.enable();
quill.enable(false);   // Disables user input
focus
Focuses the editor and restores its last range.

Methods

focus(options: { preventScroll?: boolean } = {});
Examples

// Focus the editor, and scroll the selection into view
quill.focus();

// Focus the editor, but don't scroll
quill.focus({ preventScroll: true });
hasFocus
Checks if editor has focus. Note focus on toolbar, tooltips, does not count as the editor.

Methods

hasFocus(): boolean
Examples

quill.hasFocus();
update
Synchronously check editor for user updates and fires events, if changes have occurred. Useful for collaborative use cases during conflict resolution requiring the latest up to date state. Source may be "user", "api", or "silent".

Methods

update(((source: string) = 'user'));
Examples

quill.update();
scrollRectIntoViewexperimental
Scrolls the editor to the given pixel position. scrollSelectionIntoView is implemented by calling this method with the bounds of the current selection.

scrollRectIntoView(bounds: {
  top: number;
  right: number;
  bottom: number;
  left: number;
});
Example 1

// Scroll the editor to reveal the range of { index: 20, length: 5 }
const bounds = this.selection.getBounds(20, 5);
if (bounds) {
  quill.scrollRectIntoView(bounds);
}
Example 2

let text = "";
for (let i = 0; i < 100; i += 1) {
  text += `line ${i + 1}\n`;
}

const quill = new Quill('#editor', { theme: 'snow' });
quill.setText(text);

const target = 'line 50';
const bounds = quill.selection.getBounds(
  text.indexOf(target),
  target.length
);
if (bounds) {
  quill.scrollRectIntoView(bounds);
}
Events
text-change
Emitted when the contents of Quill have changed. Details of the change, representation of the editor contents before the change, along with the source of the change are provided. The source will be "user" if it originates from the users. For example:

User types into the editor
User formats text using the toolbar
User uses a hotkey to undo
User uses OS spelling correction
Changes may occur through an API but as long as they originate from the user, the provided source should still be "user". For example, when a user clicks on the toolbar, technically the toolbar module calls a Quill API to effect the change. But source is still "user" since the origin of the change was the user's click.

APIs causing text to change may also be called with a "silent" source, in which case text-change will not be emitted. This is not recommended as it will likely break the undo stack and other functions that rely on a full record of text changes.

Changes to text may cause changes to the selection (ex. typing advances the cursor), however during the text-change handler, the selection is not yet updated, and native browser behavior may place it in an inconsistent state. Use selection-change or editor-change for reliable selection updates.

Callback Signature

handler(delta: Delta, oldContents: Delta, source: string)
Examples

quill.on('text-change', (delta, oldDelta, source) => {
  if (source == 'api') {
    console.log('An API call triggered this change.');
  } else if (source == 'user') {
    console.log('A user action triggered this change.');
  }
});
selection-change
Emitted when a user or API causes the selection to change, with a range representing the selection boundaries. A null range indicates selection loss (usually caused by loss of focus from the editor). You can also use this event as a focus change event by just checking if the emitted range is null or not.

APIs causing the selection to change may also be called with a "silent" source, in which case selection-change will not be emitted. This is useful if selection-change is a side effect. For example, typing causes the selection to change but would be very noisy to also emit a selection-change event on every character.

Callback Signature

handler(range: { index: number, length: number },
        oldRange: { index: number, length: number },
        source: string)
Examples

quill.on('selection-change', (range, oldRange, source) => {
  if (range) {
    if (range.length == 0) {
      console.log('User cursor is on', range.index);
    } else {
      const text = quill.getText(range.index, range.length);
      console.log('User has highlighted', text);
    }
  } else {
    console.log('Cursor not in the editor');
  }
});
editor-change
Emitted when either text-change or selection-change would be emitted, even when the source is "silent". The first parameter is the event name, either text-change or selection-change, followed by the arguments normally passed to those respective handlers.

Callback Signature

handler(name: string, ...args)
Examples

quill.on('editor-change', (eventName, ...args) => {
  if (eventName === 'text-change') {
    // args[0] will be delta
  } else if (eventName === 'selection-change') {
    // args[0] will be old range
  }
});
on
Adds event handler. See text-change or selection-change for more details on the events themselves.

Methods

on(name: string, handler: Function): Quill
Examples

quill.on('text-change', () => {
  console.log('Text change!');
});
once
Adds handler for one emission of an event. See text-change or selection-change for more details on the events themselves.

Methods

once(name: string, handler: Function): Quill
Examples

quill.once('text-change', () => {
  console.log('First text change!');
});
off
Removes event handler.

Methods

off(name: string, handler: Function): Quill
Examples

function handler() {
  console.log('Hello!');
}

quill.on('text-change', handler);
quill.off('text-change', handler);
Model
find
Static method returning the Quill or Blot instance for the given DOM node. In the latter case, passing in true for the bubble parameter will search up the given DOM's ancestors until it finds a corresponding Blot.

Methods

Quill.find(domNode: Node, bubble: boolean = false): Blot | Quill
Examples

const container = document.querySelector('#container');
const quill = new Quill(container);
console.log(Quill.find(container) === quill); // Should be true

quill.insertText(0, 'Hello', 'link', 'https://world.com');
const linkNode = document.querySelector('#container a');
const linkBlot = Quill.find(linkNode);

// Find Quill instance from a blot
console.log(Quill.find(linkBlot.scroll.domNode.parentElement));
getIndex
Returns the distance between the beginning of document to the occurrence of the given Blot.

Methods

getIndex(blot: Blot): number
Examples

let [line, offset] = quill.getLine(10);
let index = quill.getIndex(line); // index + offset should == 10
getLeaf
Returns the leaf Blot at the specified index within the document.

Methods

getLeaf(index: number): [LeafBlot | null, number]
Examples

quill.setText('Hello Good World!');
quill.formatText(6, 4, 'bold', true);

let [leaf, offset] = quill.getLeaf(7);
// leaf should be a Text Blot with value "Good"
// offset should be 1, since the returned leaf started at index 6
getLine
Returns the line Blot at the specified index within the document.

Methods

getLine(index: number): [Block | BlockEmbed | null, number]
Examples

quill.setText('Hello\nWorld!');

let [line, offset] = quill.getLine(7);
// line should be a Block Blot representing the 2nd "World!" line
// offset should be 1, since the returned line started at index 6
getLines
Returns the lines contained within the specified location.

Methods

getLines(index: number = 0, length: number = remaining): (Block | BlockEmbed)[]
getLines(range: Range): (Block | BlockEmbed)[]
Examples

quill.setText('Hello\nGood\nWorld!');
quill.formatLine(1, 1, 'list', 'bullet');

let lines = quill.getLines(2, 5);
// array with a ListItem and Block Blot,
// representing the first two lines
Extension
debug
Static method enabling logging messages at a given level: 'error', 'warn', 'log', or 'info'. Passing true is equivalent to passing 'log'. Passing false disables all messages.

Methods

Quill.debug(level: string | boolean)
Examples

Quill.debug('info');
import
Static method returning Quill library, format, module, or theme. In general the path should map exactly to Quill source code directory structure. Unless stated otherwise, modification of returned entities may break required Quill functionality and is strongly discouraged.

Methods

Quill.import(path): any
Examples

const Parchment = Quill.import('parchment');
const Delta = Quill.import('delta');

const Toolbar = Quill.import('modules/toolbar');
const Link = Quill.import('formats/link');
// Similar to ES6 syntax `import Link from 'quill/formats/link';`
Note
Don't confuse this with the import keyword for ECMAScript modules. Quill.import() doesn't load scripts over the network, it just returns the corresponding module from the Quill library without causing any side-effects.

register
Registers a module, theme, or format(s), making them available to be added to an editor. Can later be retrieved with Quill.import. Use the path prefix of 'formats/', 'modules/', or 'themes/' for registering formats, modules or themes, respectively. For formats specifically there is a shorthand to just pass in the format directly and the path will be autogenerated. Will overwrite existing definitions with the same path.

Methods

Quill.register(format: Attributor | BlotDefinintion, supressWarning: boolean = false)
Quill.register(path: string, def: any, supressWarning: boolean = false)
Quill.register(defs: { [path: string]: any }, supressWarning: boolean = false)
Examples

const Module = Quill.import('core/module');

class CustomModule extends Module {}

Quill.register('modules/custom-module', CustomModule);
Quill.register({
  'formats/custom-format': CustomFormat,
  'modules/custom-module-a': CustomModuleA,
  'modules/custom-module-b': CustomModuleB,
});

Quill.register(CustomFormat);
// You cannot do Quill.register(CustomModuleA); as CustomModuleA is not a format
addContainer
Adds and returns a container element inside the Quill container, sibling to the editor itself. By convention, Quill modules should have a class name prefixed with ql-. Optionally include a refNode where container should be inserted before.

Methods

addContainer(className: string, refNode?: Node): Element
addContainer(domNode: Node, refNode?: Node): Element
Examples

const container = quill.addContainer('ql-custom');
getModule
Retrieves a module that has been added to the editor.

Methods

getModule(name: string): any
Examples

const toolbar = quill.getModule('toolbar');



Documentation
Delta
Edit page on GitHub ↗
Delta
Deltas are a simple, yet expressive format that can be used to describe Quill's contents and changes. The format is a strict subset of JSON, is human readable, and easily parsible by machines. Deltas can describe any Quill document, includes all text and formatting information, without the ambiguity and complexity of HTML.

Note
Don't be confused by its name Delta—Deltas represents both documents and changes to documents. If you think of Deltas as the instructions from going from one document to another, the way Deltas represent a document is by expressing the instructions starting from an empty document.

Deltas are implemented as a separate standalone library, allowing its use outside of Quill. It is suitable for Operational Transform and can be used in realtime, Google Docs like applications. For a more in depth explanation behind Deltas, see Designing the Delta Format.

Note
It is not recommended to construct Deltas by hand—rather use the chainable insert(), delete(), and retain() methods to create new Deltas. You can use import() to access Delta from Quill.

Document
The Delta format is almost entirely self-explanatory—the example below describes the string "Gandalf the Grey" where "Gandalf" is bolded and "Grey" is colored #cccccc.

{
  ops: [
    { insert: 'Gandalf', attributes: { bold: true } },
    { insert: ' the ' },
    { insert: 'Grey', attributes: { color: '#cccccc' } }
  ]
}
As its name would imply, describing content is actually a special case for Deltas. The above example is more specifically instructions to insert a bolded string "Gandalf", an unformatted string " the ", followed by the string "Grey" colored #cccccc. When Deltas are used to describe content, it can be thought of as the content that would be created if the Delta was applied to an empty document.

Since Deltas are a data format, there is no inherent meaning to the values of attribute keypairs. For example, there is nothing in the Delta format that dictates color value must be in hex—this is a choice that Quill makes, and can be modified if desired with Parchment.

Embeds
For non-text content such as images or formulas, the insert key can be an object. The object should have one key, which will be used to determine its type. This is the blotName if you are building custom content with Parchment. Like text, embeds can still have an attributes key to describe formatting to be applied to the embed. All embeds have a length of one.

{
  ops: [{
    // An image link
    insert: {
      image: 'https://quilljs.com/assets/images/icon.png'
    },
    attributes: {
      link: 'https://quilljs.com'
    }
  }]
}
Line Formatting
Attributes associated with a newline character describes formatting for that line.

{
  ops: [
    { insert: 'The Two Towers' },
    { insert: '\n', attributes: { header: 1 } },
    { insert: 'Aragorn sped on up the hill.\n' }
  ]
}
All Quill documents must end with a newline character, even if there is no formatting applied to the last line. This way, you will always have a character position to apply line formatting to.

Many line formats are exclusive. For example Quill does not allow a line to simultaneously be both a header and a list, despite being possible to represent in the Delta format.

Changes
When you register a listener for Quill's text-change event, one of the arguments you will get is a Delta describing what changed. In addition to insert operations, this Delta might also have delete or retain operations.

Delete
The delete operation instructs exactly what it implies: delete the next number of characters.

{
  ops: [
    { delete: 10 } // Delete the next 10 characters
  ]
}
Since delete operations do not include what was deleted, a Delta is not reversible.

Retain
A retain operation simply means keep the next number of characters, without modification. If attributes is specified, it still means keep those characters, but apply the formatting specified by the attributes object. A null value for an attributes key is used to specify format removal.

Starting with the above "Gandalf the Grey" example:

// {
//   ops: [
//     { insert: 'Gandalf', attributes: { bold: true } },
//     { insert: ' the ' },
//     { insert: 'Grey', attributes: { color: '#cccccc' } }
//   ]
// }

{
  ops: [
    // Unbold and italicize "Gandalf"
    { retain: 7, attributes: { bold: null, italic: true } },

    // Keep " the " as is
    { retain: 5 },

    // Insert "White" formatted with color #fff
    { insert: 'White', attributes: { color: '#fff' } },

    // Delete "Grey"
    { delete: 4 }
  ]
}
Note that a Delta's instructions always starts at the beginning of the document. And because of plain retain operations, we never need to specify an index for a delete or insert operation.


Documentation
Modules
Edit page on GitHub ↗
Modules
Modules allow Quill's behavior and functionality to be customized. Several officially supported modules are available to pick and choose from, some with additional configuration options and APIs. Refer to their respective documentation pages for more details.

To enable a module, simply include it in Quill's configuration.

const quill = new Quill('#editor', {
  modules: {
    history: {          // Enable with custom configurations
      delay: 2500,
      userOnly: true
    },
    syntax: true        // Enable with default configuration
  }
});
The Clipboard, Keyboard, and History modules are required by Quill and do not need to be included explictly, but may be configured like any other module.

Extending
Modules may also be extended and re-registered, replacing the original module. Even required modules may be re-registered and replaced.

const Clipboard = Quill.import('modules/clipboard');
const Delta = Quill.import('delta');

class PlainClipboard extends Clipboard {
  convert(html = null) {
    if (typeof html === 'string') {
      this.container.innerHTML = html;
    }
    let text = this.container.innerText;
    this.container.innerHTML = '';
    return new Delta().insert(text);
  }
}

Quill.register('modules/clipboard', PlainClipboard, true);

// Will be created with instance of PlainClipboard
const quill = new Quill('#editor');
Note
This particular example was selected to show what is possible. It is often easier to just use an API or configuration the existing module exposes. In this example, the existing Clipboard's addMatcher API is suitable for most paste customization scenarios.


Documentation
Customization
Edit page on GitHub ↗
Customization
Quill was designed with customization and extension in mind. This is achieved by implementing a small editor core exposed by a granular, well defined API. The core is augmented by modules, using the same APIs you have access to.

In general, common customizations are handled in configurations, user interfaces by Themes and CSS, functionality by modules, and editor contents by Parchment.

Configurations
Quill favors Code over Configuration™, but for very common needs, especially where the equivalent code would be lengthy or complex, Quill provides configuration options. This would be a good first place to look to determine if you even need to implement any custom functionality.

Two of the most powerful options is modules and theme. You can drastically change or expand what Quill can and does do by simply adding or removing individual modules or using a different theme.

Themes
Quill officially supports a standard toolbar theme Snow and a floating tooltip theme Bubble. Since Quill is not confined within an iframe like many legacy editors, many visual modifications can be made with just CSS, using one of the existing themes.

If you would like to drastically change UI interactions, you can omit the theme configuration option, which will give you an unstyled Quill editor. You do still need to include a minimal stylesheet that, for example, makes sure spaces render in all browsers and ordered lists are appropriately numbered.

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/quill@2.0.3/dist/quill.core.css" />
From there you can implement and attach your own UI elements like custom dropdowns or tooltips. The last section of Cloning Medium with Parchment provides an example of this in action.

Modules
Quill is designed with a modular architecture composed of a small editing core, surrounded by modules that augment its functionality. Some of this functionality is quite integral to editing, such as the History module, which manages undo and redo. Because all modules use the same public API exposed to the developer, even interchanging core modules is possible, when necessary.

Like Quill's core itself, many modules expose additional configuration options and APIs. Before deciding to replace a module, take a look at its documentation. Often your desired customization is already implemented as a configuration or API call.

Otherwise, if you would like to drastically change functionality an existing module already covers, you can simply not include it—or explicitly exclude it when a theme includes it by default—and implement the functionality to your liking external to Quill, using the same API the default module uses.

const quill = new Quill('#editor', {
  modules: {
    toolbar: false    // Snow includes toolbar by default
  },
  theme: 'snow'
});
A few modules—Clipboard, Keyboard, and History—need to be included as core functionality depend on the APIs they provide. For example, even though undo and redo is basic, expected, editor functionality, the native browser behavior handling of this is inconsistent and unpredictable. The History module bridges the gap by implementing its own undo manager and exposing undo() and redo() as APIs.

Nevertheless, staying true to Quill modular design, you can still drastically change the way undo and redo—or any other core functionality—works by implementing your own undo manager to replace the History module. As long as you implement the same API interface, Quill will happily use your replacement module. This is most easily done by inheriting from the existing module, and overwriting the methods you want to change. Take a look at the modules documentation for a very simple example of overwriting the core Clipboard module.

Finally, you may want to add functionality not provided by existing modules. In this case, it may be convenient to organize this as a Quill module, which the Building A Custom Module guide covers. Of course, it is certainly valid to just keep this logic separate from Quill, in your application code instead.

Content and Formatting
Quill allows modification and extension of the contents and formats that it understands through its document model Parchment. Content and formats are represented in Parchment as either Blots or Attributors, which roughly correspond to Nodes or Attributes in the DOM.

Class vs Inline
Quill uses classes, instead of inline style attributes, when possible, but both are implemented for you to pick and choose. A live example of this is implemented as a Playground snippet.

const ColorClass = Quill.import('attributors/class/color');
const SizeStyle = Quill.import('attributors/style/size');
Quill.register(ColorClass, true);
Quill.register(SizeStyle, true);

// Initialize as you would normally
const quill = new Quill('#editor', {
  modules: {
    toolbar: true,
  },
  theme: 'snow',
});
Customizing Attributors
In addition to choosing the particular Attributor, you can also customize existing ones. Here is an example of the font whitelist to add additional fonts.

const FontAttributor = Quill.import('attributors/class/font');
FontAttributor.whitelist = [
  'sofia',
  'slabo',
  'roboto',
  'inconsolata',
  'ubuntu',
];
Quill.register(FontAttributor, true);
Note you still need to add styling for these classes into your CSS files.

<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" />
<style>
  .ql-font-roboto {
    font-family: 'Roboto', sans-serif;
  }
</style>
Customizing Blots
Formats represented by Blots can also be customized. Here is how you would change the DOM Node used to represent bold formatting.

const Bold = Quill.import('formats/bold');
Bold.tagName = 'B';   // Quill uses <strong> by default
Quill.register(Bold, true);

// Initialize as you would normally
const quill = new Quill('#editor', {
  modules: {
    toolbar: true
  },
  theme: 'snow'
});

const Delta = Quill.import('delta');
quill.setContents(
  new Delta()
    .insert('Rendered with <b>!', { bold: true })
    .insert('\n')
);
Extending Blots
You can also extend existing formats. Here is a quick ES6 implementation of a list item that does not permit formatting its contents. Code blocks are implemented in exactly this way.

const ListItem = Quill.import('formats/list/item');

class PlainListItem extends ListItem {
  formatAt(index, length, name, value) {
    if (name === 'list') {
      // Allow changing or removing list format
      super.formatAt(name, value);
    }
    // Otherwise ignore
  }
}

Quill.register(PlainListItem, true);

// Initialize as you would normally
const quill = new Quill('#editor', {
  modules: {
    toolbar: true,
  },
  theme: 'snow',
});
You can view a list of Blots and Attributors available by calling console.log(Quill.imports);. Direct modification of this object is not supported. Use Quill.register instead.

A complete reference on Parchment, Blots and Attributors can be found on Parchment's own README. For an in-depth walkthrough, take a look at Cloning Medium with Parchment, which starts with Quill understanding just plain text, to adding all of the formats Medium supports. Most of the time, you will not have to build formats from scratch since most are already implemented in Quill, but it is still useful to understanding how Quill works at this deeper level.


Documentation
Designing the Delta Format
Edit page on GitHub ↗
Designing the Delta Format
Rich text editors lack a specification to express its own contents. Until recently, most rich text editors did not even know what was in their own edit areas. These editors just pass the user HTML, along with the burden of parsing and interpretting this. At any given time, this interpretation will differ from those of major browser vendors, leading to different editing experiences for users.

Quill is the first rich text editor to actually understand its own contents. Key to this is Deltas, the specification describing rich text. Deltas are designed to be easy to understand and use. We will walk through some of the thinking behind Deltas, to shed light on why things are the way they are.

If you are looking for a reference on what Deltas are, the Delta documentation is a more concise resource.

Plain Text
Let's start at the basics with just plain text. There already is a ubiquitous format to store plain text: the string. Now if we want to build upon this and describe formatted text, such as when a range is bold, we need to add additional information.

Arrays are the only other ordered data type available, so we use an array of objects. This also allows us to leverage JSON for compatibility with a breadth of tools.

const content = [
  { text: 'Hello' },
  { text: 'World', bold: true }
];
We can add italics, underline, and other formats to the main object if we want to; but it is cleaner to separate text from all of this so we organize formatting under one field, which we will name attributes.

const content = [
  { text: 'Hello' },
  { text: 'World', attributes: { bold: true } }
];
Compact
Even with our simple Delta format so far, it is unpredictable since the above "Hello World" example can be represented differently, so we cannot predict which will be generated:

const content = [
  { text: 'Hel' },
  { text: 'lo' },
  { text: 'World', attributes: { bold: true } }
];
To solve this, we add the constraint that Deltas must be compact. With this constraint, the above representation is not a valid Delta, since it can be represented more compactly by the previous example, where "Hel" and "lo" were not separate. Similarly we cannot have { bold: false, italic: true, underline: null }, because { italic: true } is more compact.

Canonical
We have not assigned any meaning to bold, just that it describes some formatting for text. We could very well have used different names, such as weighted or strong, or used a different range of possible values, such as a numerical or descriptive range of weights. An example can be found in CSS, where most of these ambiguities are at play. If we saw bolded text on a page, we cannot predict if its rule set is font-weight: bold or font-weight: 700. This makes the task of parsing CSS to discern its meaning, much more complex.

We do not define the set of possible attributes, nor their meanings, but we do add an additional constraint that Deltas must be canonical. If two Deltas are equal, the content they represent must be equal, and there cannot be two unequal Deltas that represent the same content. Programmatically, this allows you to simply deep compare two Deltas to determine if the content they represent is equal.

So if we had the following, the only conclusion we can draw is a is different from b, but not what a or b means.

const content = [{
  text: "Mystery",
  attributes: {
    a: true,
    b: true
  }
}];
It is up to the implementer to pick appropriate names:

const content = [{
  text: "Mystery",
  attributes: {
    italic: true,
    bold: true
  }
}];
This canonicalization applies to both keys and values, text and attributes. For example, Quill by default:

Uses six character hex values to represent colors and not RGB
There is only one way to represent a newline which is with \n, not \r or \r\n
text: "Hello  World" unambiguously means there are precisely two spaces between "Hello" and "World"
Some of these choices may be customized by the user, but the canonical constraint in Deltas dictate that the choice must be unique.

This unambiguous predictability makes Deltas easier to work with, both because you have fewer cases to handle and because there are no surprises in what a corresponding Delta will look like. Long term, this makes applications using Deltas easier to understand and maintain.

Line Formatting
Line formats affect the contents of an entire line, so they present an interesting challenge for our compact and canonical constraints. A seemingly reasonable way to represent centered text would be the following:

const content = [
  { text: "Hello", attributes: { align: "center" } },
  { text: "\nWorld" }
];
But what if the user deletes the newline character? If we just naively get rid of the newline character, the Delta would now look like this:

const content = [
  { text: "Hello", attributes: { align: "center" } },
  { text: "World" }
];
Is this line still centered? If the answer is no, then our representation is not compact, since we do not need the attribute object and can combine the two strings:

const content = [
  { text: "HelloWorld" }
];
But if the answer is yes, then we violate the canonical constraint since any permutation of characters having an align attribute would represent the same content.

So we cannot just naively get rid of the newline character. We also have to either get rid of line attributes, or expand them to fill all characters on the line.

What if we removed the newline from the following?

const content = [
  { text: "Hello", attributes: { align: "center" } },
  { text: "\n" },
  { text: "World", attributes: { align: "right" } }
];
It is not clear if our resulting line is aligned center or right. We could delete both or have some ordering rule to favor one over the other, but our Delta is becoming more complex and harder to work with on this path.

This problem begs for atomicity, and we find this in the newline character itself. But we have an off by one problem in that if we have n lines, we only have n-1 newline characters.

To solve this, Quill "adds" a newline to all documents and always ends Deltas with "\n".

// Hello World on two lines
const content = [
  { text: "Hello" },
  { text: "\n", attributes: { align: "center" } },
  { text: "World" },
  { text: "\n", attributes: { align: "right" } }   // Deltas must end with newline
];
Embedded Content
We want to add embedded content like images or video. Strings were natural to use for text but we have a lot more options for embeds. Since there are different types of embeds, our choice just needs to include this type information, and then the actual content. There are many reasonable options here but we will use an object whose only key is the embed type and the value is the content representation, which may have any type or value.

const img = {
  image: {
    url: 'https://quilljs.com/logo.png'
  }
};

const f = {
  formula: 'e=mc^2'
};
Similar to text, images might have some defining characteristics, and some transient ones. We used attributes for text content and can use the same attributes field for images. But because of this, we can keep the general structure we have been using, but should rename our text key into something more general. For reasons we will explore later, we will choose the name insert. Putting this all together we have:

const content = [{
  insert: 'Hello'
}, {
  insert: 'World',
  attributes: { bold: true }
}, {
  insert: {
    image: 'https://exclamation.com/mark.png'
  },
  attributes: { width: '100' }
}];
Describing Changes
As the name Delta implies, our format can describe changes to documents, as well as documents themselves. In fact we can think of documents as the changes we would make to the empty document, to get to the one we are describing. As you might have already guessed, using Deltas to also describe changes is why we renamed text to insert earlier. We call each element in our Delta array an Operation.

Delete
To describe deleting text, we need to know where and how many characters to delete. To delete embeds, there needs not be any special treatment, other than to understand the length of an embed. If it is anything other than one, we would then need to specify what happens when only part of an embed is deleted. There is currently no such specification, so regardless of how many pixels make up an image, how many minutes long a video is, or how many slides are in a deck; embeds are all of length one.

One reasonable way to describe a deletion is to explicitly store its index and length.

const delta = [{
  delete: {
    index: 4,
    length: 1
  }
}, {
  delete: {
    index: 12,
    length: 3
  }
}];
We would have to order the deletions based on indexes, and ensure no ranges overlap, otherwise our canonical constraint would be violated. There are a couple other shortcomings to this index and length approach, but they are easier to appreciate after describing format changes.

Insert
Now that Deltas may be describing changes to a non-empty document, { insert: "Hello" } is insufficient, because we do not know where "Hello" should be inserted. We can solve this by also adding an index, similar to delete.

Format
Similar to deletes, we need to specify the range of text to format, along with the format change itself. Formatting exists in the attributes object, so a simple solution is to provide an additional attributes object to merge with the existing one. This merge is shallow to keep things simple. We have not found a use case that is compelling enough to require a deep merge and warrants the added complexity.

const delta = [{
  format: {
    index: 4,
    length: 1
  },
  attributes: {
    bold: true
  }
}];
The special case is when we want to remove formatting. We will use null for this purpose, so { bold: null } would mean remove the bold format. We could have specified any falsy value, but there may be legitimate use cases for an attribute value to be 0 or the empty string.

Note: We now have to be careful with indexes at the application layer. As mentioned earlier, Deltas do not ascribe any inherent meaning to any the attributes' key-value pairs, nor any embed types or values. Deltas do not know an image does not have duration, text does not have alternative texts, and videos cannot be bolded. The following is a legal Delta that might have been the result of applying other legal Deltas, by an application not being careful of format ranges.

const delta = [{
  insert: {
    image: "https://imgur.com/"
  },
  attributes: {
    duration: 600
  }
}, {
  insert: "Hello",
  attributes: {
    alt: "Funny cat photo"
  }
}, {
  insert: {
    video: "https://youtube.com/"
  },
  attributes: {
    bold: true
  }
}];
Pitfalls
First, we should be clear that an index must refer to its position in the document before any Operations are applied. Otherwise, a later Operation may delete a previous insert, unformat a previous format, etc., which would violate compactness.

Operations must also be strictly ordered to satisfy our canonical constraint. Ordering by index, then length, and then type is one valid way this can be accomplished.

As stated earlier, delete ranges cannot overlap. The case against overlapping format ranges is less brief, but it turns out we do not want overlapping formats either.

The number of reasons a Delta might be invalid is piling up. A better format would simply not allow such cases to be expressed at all.

Retain
If we step back from our compactness formalities for a moment, we can describe a much simpler format to express inserting, deleting, and formatting:

A Delta would have Operations that are at least as long as the document being modified.
Each Operation would describe what happens to the character at that index.
Optional insert Operations may make the Delta longer than the document it describes.
This necessitates the creation of a new Operation, that will simply mean "keep this character as is". We call this a retain.

// Starting with "HelloWorld",
// bold "Hello", and insert a space right after it
const change = [
  { format: true, attributes: { bold: true } },  // H
  { format: true, attributes: { bold: true } },  // e
  { format: true, attributes: { bold: true } },  // l
  { format: true, attributes: { bold: true } },  // l
  { format: true, attributes: { bold: true } },  // o
  { insert: ' ' },
  { retain: true },  // W
  { retain: true },  // o
  { retain: true },  // r
  { retain: true },  // l
  { retain: true }   // d
]
Since every character is described, explicit indexes and lengths are no longer necessary. This makes overlapping ranges and out-of-order indexes impossible to express.

Therefore, we can make the easy optimization to merge adjacent equal Operations, re-introducing length. If the last Operation is a retain we can simply drop it, for it simply instructs to "do nothing to the rest of the document".

const change = [
  { format: 5, attributes: { bold: true } }
  { insert: ' ' }
]
Furthermore, you might notice that a retain is in some ways just a special case of format. For instance, there is no practical difference between { format: 1, attributes: {} } and { retain: 1 }. Compacting would drop the empty attributes object leaving us with just { format: 1 }, creating a canonicalization conflict. Thus, in our example we will simply combine format and retain, and keep the name retain.

const change = [
  { retain: 5, attributes: { bold: true } },
  { insert: ' ' }
]
We now have a Delta that is very close to the current standard format.

Ops
Right now we have an easy to use JSON Array that describes rich text. This is great at the storage and transport layers, but applications could benefit from more functionality. We can add this by implementing Deltas as a class, that can be easily initialized from or exported to JSON, and then providing it with relevant methods.

At the time of Delta's inception, it was not possible to sub-class an Array. For this reason Deltas are expressed as Objects, with a single property ops that stores an array of Operations like the ones we have been discussing.

const delta = {
  ops: [{
    insert: 'Hello'
  }, {
    insert: 'World',
    attributes: { bold: true }
  }, {
    insert: {
    image: 'https://exclamation.com/mark.png'
    },
    attributes: { width: '100' }
  }]
};
Finally, we arrive at the Delta format, as it exists today.
